#!/usr/bin/env python
#
# midi2e2
# Copyright (C) 2008-2009 sk89q <http://sk89q.therisenrealm.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# $Id$

"""
This module writes E2 files.
"""

__all__ = ('E2VectorWriter',
           'E2Writer')

from m2e2.writers import Writer

e2base = """
# Generated by midi2e2: http://github.com/sk89q/gmod/tree/master/midi2e2

@name Converted Song (via midi2e2)
@outputs Index Length Time TimeLength
@persist S:array Start Channels:array ChannelSounds:array ChannelCount

if (first() | duped()) {
%DATA%
    ChannelCount = 8
    ChannelSounds[1, string] = "synth/sine.wav"
    ChannelSounds[2, string] = "synth/tri.wav"
    ChannelSounds[3, string] = "synth/sine.wav"
    ChannelSounds[4, string] = "synth/tri.wav"
    ChannelSounds[5, string] = "synth/sine.wav"
    ChannelSounds[6, string] = "synth/tri.wav"
    ChannelSounds[7, string] = "synth/sine.wav"
    ChannelSounds[8, string] = "synth/tri.wav"

    # Only one sound per entity, so we need to create some holograms
    # to act as our players
    for (I = 0, ChannelCount) {
        holoCreate(I, entity():pos(), vec())
        holoParent(I, entity())
    }

    Start = curtime() * 1000
    Length = S:count()
    TimeLength = S[S:count(), vector]:z() / 1000
    interval(10)
} elseif (clk()) {
    while (1) {
        Now = curtime() * 1000
        Time = (Now - Start) / 1000

        if (Index >= S:count()) { # Song is over
            if (S[S:count(), vector]:z() <= Now - Start) { # Stopped playing
                Start = Now
                Index = 0
                Channels = array()
            } else {
                break
            }
        }
        
        Note = S[Index, vector]
        if (Note:y() <= Now - Start) { # Y is start time
            # We have to play the note
            for (I = 1, ChannelCount) {
                if (Channels[I, number] + 100 < Now - Start) {
                    Freq = (440 / 32) * (2^((Note:x() - 9) / 12))
                    Pitch = Freq * 5 / 22
                    holoEntity(I):soundPlay(Index, (Note:z() - Note:y()) / 1000, ChannelSounds[I, string])
                    soundPitch(Index, Pitch)
                    Channels[I, number] = Note:z()
                    break
                }
            }
        } else {
            break
        }

        Index++
    }
    interval(10)
}
"""

class E2VectorWriter(Writer):
    def write(self):
        # We need to sort the notes first
        notes = list(self.data.notes)
        def sort(a, b):
            if a.start == b.start: return 0
            elif a.start < b.start: return -1
            else: return 1
        notes.sort(sort)
        
        # Notes
        index = 0
        for n in notes:
            self.f.write("S[%d,vector]=vec(%d,%d,%d)\r\n" % (index, n.note, n.start, n.end))
            index = index + 1

class E2Writer(Writer):
    def write(self):
        vw = E2VectorWriter(self.data, self.f)
        base = e2base.replace("\r\n", "\n").replace("\n", "\r\n").split("%DATA%")
        
        self.f.write(base[0])
        vw.write()
        self.f.write(base[1])