# Generated by midi2e2: http://github.com/sk89q/gmod/tree/master/midi2e2

@name Converted Song (via midi2e2)
@persist S:array Start Index Channels:array ChannelSounds:array ChannelCount

if (first() | duped()) {
%DATA%
    ChannelCount = 8
    ChannelSounds[1, string] = "synth/sine.wav"
    ChannelSounds[2, string] = "synth/tri.wav"
    ChannelSounds[3, string] = "synth/sine.wav"
    ChannelSounds[4, string] = "synth/tri.wav"
    ChannelSounds[5, string] = "synth/sine.wav"
    ChannelSounds[6, string] = "synth/tri.wav"
    ChannelSounds[7, string] = "synth/sine.wav"
    ChannelSounds[8, string] = "synth/tri.wav"

    # Only one sound per entity, so we need to create some holograms
    # to act as our players
    for (I = 0, ChannelCount) {
        holoCreate(I, entity():pos(), vec())
        holoParent(I, entity())
    }

    Start = curtime() * 1000
    interval(10)
} elseif (clk()) {
    while (1) {
        Now = curtime() * 1000

        if (Index >= S:count()) { # Song is over
            Start = Now
            Index = 0
            Channels = array()
            # TODO: Wait until song ends
        }

        Note = S[Index, vector]
        if (Note:y() <= Now - Start) { # Y is start time
            # We have to play the note
            for (I = 1, ChannelCount) {
                if (Channels[I, number] < Now - Start) {
                    Freq = (440 / 32) * (2^((Note:x() - 9) / 12))
                    Pitch = Freq * 5 / 22
                    NoteIndex++
                    holoEntity(I):soundPlay(Index, (Note:z() - Note:y()) / 1000, ChannelSounds[I, string])
                    soundPitch(NoteIndex, Pitch)
                    Channels[I, number] = Note:z()
                    break
                }
            }
        } else {
            break
        }

        Index++
    }
    interval(10)
}