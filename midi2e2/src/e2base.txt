# Generated by midi2ew: http://github.com/sk89q/gmod/tree/master/midi2e2

@name Converted Song (via midi2e2)
@persist S:array Start Index Channels:array ChannelSounds:array ChannelCount

if (first() | duped()) {
%DATA%
    ChannelCount = 5
    ChannelSounds[0, string] = "synth/sine.wav"
    ChannelSounds[1, string] = "synth/tri.wav"
    ChannelSounds[2, string] = "synth/sine.wav"
    ChannelSounds[3, string] = "synth/tri.wav"
    ChannelSounds[4, string] = "synth/sine.wav"
    ChannelSounds[5, string] = "synth/tri.wav"
    
    # Only one sound per entity, so we need to create some holograms
    # to act as our players
    for (I = 0, ChannelCount) {
        holoCreate(I, entity():pos(), vec())
        holoParent(I, entity())
    }

    Start = curtime() * 1000
    runOnTick(10000) # TODO: This needs to be adjusted
} elseif (tickClk()) {    
    while (1) {
        Now = curtime() * 1000
        
        if (Index >= S:count()) { # Song is over
            Start = Now
            Index = 0
        }
        
        Note = S[Index, vector]
        if (Note:y() <= Now - Start) { # Y is start time
            # We have to play the note
            for (I = 0, ChannelCount) {
                if (Channels[I, number] < Now - Start) {
                    Freq = (440 / 32) * (2^((Note:x() - 9) / 12))
                    Pitch = Freq * 5 / 22
                    holoEntity(I):soundPlay(I, Note:z() / 1000, ChannelSounds[I, string])
                    soundPitch(I, Pitch)
                    Channels[I, number] = Note:z()
                    print("Playing " + toString(Freq) + " on ch. " + toString(I))
                    break
                }
            }
        } else {
            break
        }
        
        Index++
    }
}